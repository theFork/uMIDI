<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>uMIDI: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">uMIDI
   </div>
   <div id="projectbrief">The swiss army knife for quick and easy developement of MIDI applications.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">uMIDI Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro"></a>
What is uMIDI?</h1>
<p>uMIDI is a small general purpose micro-controller board built to receive, forward and send MIDI messages accompanied by a (soon to become ;-) quite sophisticated software library / framework. You can use uMIDI for virtually everything you can think of involving (but not limited to) MIDI:</p>
<ul>
<li>MIDI merging / splitting</li>
<li>MIDI controllers (trigger pads, pedals, sequencers, ...)</li>
<li>MIDI-controllable devices (Guitar/Bass/Synth effects, possibly visual effects)</li>
<li>and the list goes on...</li>
</ul>
<p>The board is also equipped with a mini USB port, which in conjunction with the serial communication module allows you to connect the board to your PC as a character device.</p>
<div class="image">
<img src="board.jpg" alt="board.jpg"/>
<div class="caption">
The uMIDI board</div></div>
 <h1><a class="anchor" id="features"></a>
Hardware features</h1>
<ul>
<li>receive / forward / send arbitrary MIDI messages</li>
<li>control interface via USB character device</li>
<li>24 GPIO ports with special functions:<ul>
<li>1x SPI</li>
<li>2x UART</li>
<li>8x ADC</li>
<li>2x DAC</li>
<li>6x PWM</li>
</ul>
</li>
<li>4 GPIO ports connected to solder jumpers</li>
<li>2 LEDs (red + green)</li>
</ul>
<p>See also:</p><ul>
<li><a class="el" href="pin_mapping.html">micro-controller pin mapping</a></li>
<li><a class="el" href="midi_pinout.html">MIDI pinout and phantom-power specification</a></li>
</ul>
<h1><a class="anchor" id="software"></a>
Software library</h1>
<p>uMIDI comes with a quite sophisticated high-level software library and framework, which enables you to accomplish most basic tasks very quickly. You can find the documentation of the API at <a href="../../software/src/lib">software/src/lib</a> - if you intend to simply use the library as-is, looking at the header files should suffice.</p>
<p>The framework features easy to use device initialization routines which provide an abstraction from the hardware. You just need to specify, which features (GPIO, ADC, PWM, ...) you want to use and how they should be set up with a set of configuration <code>struct</code>s and pass those to the initialization routines - no bit-masking / -shifting or other error-prone steps required. It is recommended to keep all your configuration structures in one file - this way you have one single place, where all hardware-related information can be found.</p>
<p>Background tasks whose call-frequency may jitter to some extend can be implemented very comfortably using the <a class="el" href="background__tasks_8h.html">background tasks module</a>. The module uses "system ticks" from a CPU timer to schedule registered tasks at three different base frequencies. Of course you can use a counter to further divide down the call-frequency of a specific task.</p>
<p>The two on-board LEDs can be controlled by the corresponding <a class="el" href="leds_8h.html">LEDs module</a>. The LEDs can be in one of three modes (static, blinking or flashing once), which are managed by a background task. You can set the mode and/or (in static mode) toggle LEDs manually via service functions. This can be done separately for each LED or for both LEDs at the same time.</p>
<p>The <a class="el" href="gpio_8h.html">GPIO module</a> is dedicated to.. well.. the GPIO pins. It offers service procedures to set and poll GPIO pins and an easy way to configure all pins with a single data structure.</p>
<p>If you want to implement some kind of modulation with a specific waveform like a sine or triangle wave, you should look into the <a class="el" href="wave_8h.html">wave module</a>. This module lets you define waves - again via configuration structures - in terms of waveform, frequency, amplitude and offset. A special background task can then be used to periodically update the output value of a wave. You can even register one wave to react to tap tempo events, in which case a second background task listens for such events and updates the registered wave's frequency accordingly.</p>
<p>Some non-trivial waveforms are not computed from scratch every time - they are read from <a class="el" href="lookup__tables_8h.html">lookup tables</a>, which are generated during the build process by a small <a href="../../toolchain/compute_lookup_tables.pl">PERL script</a>. These tables also contain "linear to logarithmic" and "linear to exponential" translations in case you need them. The x-resolution of the tables is fixed at 100 values, but you can adjust the amplitude resolution of the log/exp lookup tables in the Makefile, if you need to. In order to do this, you just have to change the <code>LOOKUP_TABLES_YRES</code> variable in the Makefile.</p>
<p>The lookup tables can also be used in conjunction with the <a class="el" href="pwm_8h.html">PWM module</a>. In fact, the logarithmic and exponential functions are intended for this. You can use a linear MIDI expression value to drive a PWM output exponentially. This may come in handy, as loudness for example is perceived logarithmically. The samples in the exponential / logarithmic tables can be used directly as counter compare values for a 10 bit PWM - if you have to configure your PWM for a different counter resolution, you may have to adjust the amplitude resolution of the tables (see previous paragraph).</p>
<p>The <a class="el" href="math_8h.html">math module</a> is a rather loose collection of small helper functions for mathematical computations. There is, for example, a function that linearly scales MIDI values [0..127] to an arbitrary configurable output range, which could also be used to convert MIDI values to PWM counter compare values. There are also some basic fixed-point math functions that you can use to convert normal 16 bit integers to 16+16 bit fixed-point for high precision computations. For now, only multiplication and division are implemented (use the standard +/- operators for addition and subtraction). After the fixed-point computations are finished, the result can easily be converted back to a 16 bit integer.</p>
<p>The framework also provides ready-to-use USB support built on top of the famous <a href="https://github.com/abcminiuser/lufa">LUFA</a> library, which allows you to</p><ul>
<li>connect uMIDI devices to a PC as a character device,</li>
<li>print out logging and/or debugging information,</li>
<li>control your board using a shell-like command-line interpreter and</li>
<li>perform firmware upgrades via USB.</li>
</ul>
<p>The <a class="el" href="usb_8h.html">USB module</a> implements a CDC device and provides a simple and familiar interface inspired by <code>&lt;stdio.h&gt;</code>. To get USB up and running you only need to configure the PLL to provide a 48 kHz clock for the USB hardware, call the initialization routine and register a background task that calls some <a href="https://github.com/abcminiuser/lufa">LUFA</a> procedures to do the actual work.</p>
<p>The file <a href="../../toolchain/99-umidi.rules">99-umidi.rules</a> shows an example of a <code>udev</code>-rule that creates an alias for the character device named <code>/dev/umidi</code> whenever a uMIDI device is attached. This way you don't have to tell <code>minicom</code> over and over again which device to use in case you are working with multiple character devices attached to your workstation.</p>
<p>Higher-level USB functionality is implemented in the <a class="el" href="serial__communication_8h.html">serial communication module</a>. It provides a command-line interpreter (featuring a short history and tab-completion) for which you can define and register arbitrary custom commands via configuration structures and callbacks. There are also some built-in commands, one of which receives a new firmware, writes it to a special program memory section and reboots the device into the <a href="https://github.com/alexforencich/xboot">xboot</a> bootloader, which then replaces the old firmware with the new one. See <a class="el" href="index.html#bootloader">Building and installing the bootloader</a> for further instructions on the bootloader.</p>
<p>Furthermore, the library contains modules for several peripheral devices:</p><ul>
<li>3-phase encoder with momentary switch</li>
<li>4-phase encoder with momentary switch</li>
<li><a href="https://github.com/haggl/uMIDI-hmi">uMIDI-hmi</a>, a prototyping board featuring two encoders with momentary switch, two stand-alone momentary switches and eight LEDs</li>
</ul>
<h1><a class="anchor" id="start"></a>
Getting started</h1>
<p>This repository contains the source code for several (example) applications:</p><ul>
<li><a href="../../software/src/expression">An expression pedal</a></li>
<li><a href="../../software/src/whammy">A special sequencer for the DigiTech Whammy pedal</a></li>
<li><a href="../../software/src/switcher">A guitar effects switcher</a></li>
<li><a href="../../software/src/wah">A MIDI controllable Wah-Wah</a></li>
</ul>
<p>You can look at those to get a general idea of how the API is designed and used. In addition, there are two project templates:</p><ul>
<li><a href="../../software/src/template-nousb">A very minimalistic project without USB support</a></li>
<li><a href="../../software/src/template-usb">An empty project with USB support</a></li>
</ul>
<p>If you want to be able to use the serial communication module to talk to your board, you should start with the latter, as all necessary files are already included in the Makefile and mandatory steps to get the USB transceiver up and running are already implemented.</p>
<h1><a class="anchor" id="building"></a>
Build instructions</h1>
<p>The following software packages are required to successfully build the firmware:</p><ul>
<li><code>avr-gcc</code> &gt;= 4.8</li>
<li><code>avrdude</code> &gt;= 6.1</li>
<li><code>make</code></li>
<li><code>perl</code></li>
</ul>
<p>Fairly recent (in Debian terms ;-) versions of <code>avr-gcc</code> and <code>avrdude</code> are required, because older versions do not yet fully support the xmega128a4u chip. As of Debian Jessie, you can simply use the official repositories.</p>
<p>There are two basic "flavors" of the uMIDI firmware: Either you use the USB module with all its wonderful features, or you don't. In most cases, having USB support comes in <em>very</em> handy, so this is most likely a feature you want to have. However, if you choose to do so, you have to include the <a href="https://github.com/abcminiuser/lufa">LUFA</a> library, which consequently leads to significantly larger (about 6 kB) firmware binaries. But keeping in mind the fairly large program memory of the micro-controller, this should rarely be a problem.</p>
<p>The repository uses two submodules that are required for the build process (only with USB support). So it is best to clone those along with uMIDI: <br />
 <code>git clone --recursive git@github.com/theFork/uMIDI.git</code></p>
<p>The <a href="../../toolchain/">toolchain</a>-folder contains two standard Makefiles - one for each flavor. By starting the make-process without specifying a target shows a help message explaining all available targets. For most basic applications it should not be necessary to edit the Makefiles - except from the variable <code>AVRDUDE_PROGRAMMER_CONFIG</code>, which tells <code>avrdude</code> what programmer type to use. You can either edit the Makefile or override the option on the command line, for example: <br />
 <code>AVRDUDE_PROGRAMMER_CONFIG=dragon_pdi make install</code></p>
<p>Once you have successfully installed a firmware with USB support, you can upgrade firmwares without the need for a programmer. The <code>make</code>-target "package" converts the .hex file to binary and then uses a toolchain script called <a href="../../toolchain/pack_fwupdate.pl">pack_fwupdate.pl</a> to create a firmware update file, which you can send to your device through a simple pipe after telling the device how many bytes to expect. Of course there is also a target "fwupdate", which takes care of this for you automagically.</p>
<h1><a class="anchor" id="bootloader"></a>
Building and installing the bootloader</h1>
<p>The firmware upgrade requires the <a href="https://github.com/alexforencich/xboot">xboot</a> bootloader, which is included as a submodule. The bootloader does not need to do very much - it only has to copy the new firmware from one place in program space to another.</p>
<p>A suitable configuration file that disables all unnecessary features can be found at <a href="../../src/lib/xboot/conf/x128a4u.conf.mk">conf/x128a4u.conf.mk</a> in the submodule. If the programmer you are using is not an <code>atmelice_pdi</code> type, you will need to adjust the variable <code>AVRDUDE_PROGRAMMER</code> accordingly.</p>
<p>To build and install the bootloader, navigate to the <a href="../../src/lib/xboot">xboot submodule</a> and cast <br />
 <code>make conf/x128a4u.conf.mk &amp;&amp; make program</code>.</p>
<h1><a class="anchor" id="contributing"></a>
Contributing</h1>
<p>We would very much like to see contributions to the library / framework and more applications. If you would like to submit patches, here is a quick checklist of requirements:</p>
<ul>
<li>Please adhere to the existing code style (Yes, we are very picky!).</li>
<li>There is an additional global <a href="../../Makefile">Makefile</a>, which cleans and compiles the library, all projects and this documentation. Please make sure that all of this succeeds without errors or warnings (<code>make &gt;/dev/null</code> should print out nothing).</li>
<li>If you are unsure about something, feel free to contact us via github.</li>
</ul>
<p>We also accept bugreports and feature requests on github. Should you find a bug or miss a feature, feel free to file an issue.</p>
<h2><a class="anchor" id="hardware_contribution"></a>
Hardware</h2>
<p>The board was orinially created using the open-source EDA tool KiCad (BZR 5122) and updated to also work with BZR 6188. Other versions of KiCad <em>might</em> work as well. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 26 2016 21:08:51 for uMIDI by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
